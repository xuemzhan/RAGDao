# D5：元数据与过滤(Metadata & Filtering)

## **为何需要元数据过滤**

纯粹的向量搜索只关心语义，但真实世界的查询往往是“语义 + 条件”的组合。例如：“查找关于RAG优化的、发布于2024年之后的、作者为张三的技术博客”。这里的发布年份和作者就是元数据。

## **过滤的三种模式**

- **预过滤 (Pre-filtering):** 先根据元数据筛选出一个文档子集，然后仅在这个子集内进行向量搜索。
- **后过滤 (Post-filtering):** 先进行向量搜索，召回Top-K个候选者，然后再对这K个候选者应用元数据过滤器。
- **集成过滤 (Integrated Filtering):** 在ANN索引的遍历算法中同时进行过滤。这是现代向量数据库（如Qdrant, Milvus, Weaviate）的**最优解决方案**，兼顾了速度和准确性。

## **可执行代码示例 (使用Qdrant)**

```python
# 准备环境:
# pip install qdrant-client sentence-transformers

from qdrant_client import QdrantClient, models
from sentence_transformers import SentenceTransformer

# 1. 初始化一个内存中的Qdrant客户端
client = QdrantClient(":memory:") 

# 2. 创建一个collection，并指定向量参数
client.recreate_collection(
    collection_name="tech_blogs",
    vectors_config=models.VectorParams(size=384, distance=models.Distance.COSINE)
)

# 3. 准备数据并嵌入
model = SentenceTransformer('all-MiniLM-L6-v2')
docs = [
    "A guide to optimizing RAG pipelines in 2024.",
    "The history of Large Language Models, an article from 2022.",
    "Advanced RAG techniques for production systems, published in 2025."
]
# payload 就是 Qdrant 中的元数据
payloads = [
    {"year": 2024, "type": "blog"},
    {"year": 2022, "type": "article"},
    {"year": 2025, "type": "blog"}
]

# 4. 添加数据到collection
client.upload_points(
    collection_name="tech_blogs",
    points=models.Batch(
        ids=list(range(len(docs))),
        vectors=model.encode(docs).tolist(),
        payloads=payloads
    ),
    wait=True
)
print("Documents uploaded to Qdrant collection.")

# 5. 执行带过滤的混合查询
query_text = "How to improve RAG performance?"
query_vector = model.encode(query_text).tolist()

# 定义过滤器：年份必须大于等于(gte)2024，且类型必须是'blog'
search_filter = models.Filter(
    must=[ # 必须满足所有条件 (AND)
        models.FieldCondition(key="year", range=models.Range(gte=2024)),
        models.FieldCondition(key="type", match=models.MatchValue(value="blog"))
    ]
)

# 执行搜索
hits = client.search(
    collection_name="tech_blogs",
    query_vector=query_vector,
    query_filter=search_filter,
    limit=5
)

print(f"\nPerforming query: '{query_text}' with filter: year >= 2024 AND type == 'blog'")
print("\n--- Query Results ---")
for hit in hits:
    print(f"Score: {hit.score:.4f}")
    print(f"  - Payload: {hit.payload}")
    # print(f"  - Document: {hit.document}") # payload中可以存document全文

# 期望只返回2024年和2025年的两条blog，而2022年的文章会被过滤掉。
```